#!/usr/bin/env bash
# shellcheck disable=2076
usage="latexmk [OPTIONS] FILE"
doc="
This script compiles LaTeX documents similar to latexmk but with custom
features and designed for use with vim. Opens the resulting typeset file in a
PDF viewer then brings the terminal from which this script was invoked back to
the foreground. This is perfect for split-window workflow, with left terminal
on left side of screen and PDF viewer on right side.

Usage

  $usage

Positional arguments

  FILE

Optional arguments

  -h|--help   Print this message.
  -r|--raw    Print raw, unfiltered error messages. By default this script
              filters and parses the latex engine output so it is much easier
              to peruse.
  -d|--diff   Run latexdiff on most 'recent' file. Requires files in your
              directory are otherwise identically named, but end with unique
              date strings YYYY-MM.tex or YYYY-MM-DD.tex
  -w|--word   Pass -w or --word to automatically convert latex to the Microsoft
              Word format using pandoc. Useful for colaborating with peers that
              do not use latex.
  -p|--pull   Run 'git pull origin master' before compiling the document.
              This can be used to refresh figures updated from a remote
              clone of this repository (e.g. a supercomputer) on the fly.

Additional features

  * Never generate random extra files again. We query existing files before and
    after compilation, then remove the new ones. This is implemented with an
    EXIT signal trap, and so works if latexmk is interrupted.
  * If you add custom style and theme files to a '~/latex' folder, this script
    will try to copy relevant files to the working directory when they are
    not found in the TeXLive distribution with 'kpsewhich'.
"
# Function for raising error
raise() {
  echo "Usage: $usage" 1>&2
  echo "Error: $*" 1>&2
  exit 1
}
# Exit trap function
cleanup() {
  local files_rm files_new
  [ -n "$files_old" ] || return 0
  files_new=(*)  # new files
  ext_ignore=(tex bbl pdf docx png jpg jpeg eps gif)
  for file_new in "${files_new[@]}"; do
    [[ " ${files_old[*]} " =~ " $file_new " ]] && continue
    [[ " ${ext_ignore[*]} " =~ " ${file_new##*.} " ]] && continue
    files_rm+=("$file_new")
  done
  rm "${files_rm[@]}"
  echo "Removed files: ${files_rm[*]}"
}

# Commands
which gsed &>/dev/null && sedcmd=gsed || sedcmd=sed
[ -n "$OSTYPE" ] && [[ "$OSTYPE" =~ darwin* ]] && [ "$sedcmd" == sed ] && \
  raise "GNU sed needed when running this script on OSX. Can be installed from Homebrew with 'brew install gnu-sed'."

# Parse args
trap cleanup EXIT  # remove files on exit or interruption!
shopt -s nullglob  # glob-expand into zero entries
raw=false
pull=false
latex=pdflatex  # by default use pdflatex
bibtex=bibtex   # for compiling bibliographies
texdiff=false   # get difference pdf?
tex2docx=false  # option
while [ $# -gt 0 ]; do
  case $1 in
    -h|--help) echo "$doc" && exit 0 ;;
    -r|--raw)  raw=true ;;
    -d|--diff) texdiff=true ;;
    -w|--word) tex2docx=true ;;
    -p|--pull) pull=true ;;
    [^-]*)
      [ -n "$filename" ] && raise "Got multiple filenames."
      filename="$1"
      ;;
    *) raise "Unknown arg $1."
  esac
  shift
done
[ -n "$filename" ] || raise "Must pass filename."
[ -r "$filename" ] || raise "File '$filename' does not exist."

# Get terminal program
if [ -z "$TERM_PROGRAM" ]; then
  terminal=MacVim
elif [[ "$TERM_PROGRAM" =~ 'Apple_Terminal' ]]; then  # or e.g. Apple_Terminal2.0
  terminal=Terminal
else
  terminal=$TERM_PROGRAM
fi

# Get paths
templates=$HOME/latex  # location of LaTeX templates and style files
echo "Filename: $filename"
if [[ "$filename" =~ / ]]; then  # i.e. contains directory specifier
  directory=${filename%/*}  # trim shortest pattern matching <stuff>/*, keep "stuff"
  filename=${filename##*/}  # trim longest pattern matching */<stuff>, keep "stuff"
  cd "$directory" || raise "Directory $directory does not exist."
fi
filestem=${filename%.tex}  # simple

# Update repository
if $pull; then
  git pull origin master
fi

#-----------------------------------------------------------------------------#
# Helper regex functions
#-----------------------------------------------------------------------------#
# General utilities
nocomments() {  # ignore comments. TODO: Maybe awk is better?
  [ $# -eq 1 ] || raise "Incorrect usage of nocomments."
  grep -o '^[^%]*' "$1"
}
inbraces() {  # get content inside braces
  cut -s -d'{' -f2 | cut -s -d'}' -f1 | tr ',' ' '
}

# Search tex file for various dependencies
get_bibnames() {  # show bibliography files
  [ $# -eq 1 ] || raise "Incorrect usage of get_bibnames."
  nocomments "$1" \
    | $sedcmd -n 's/\\\(bibliography\|nobibliography\|addbibresource\){\(.*\)}/\2/p' \
    | xargs
}
get_bibstyles() {
  [ $# -eq 1 ] || raise "Incorrect usage of get_bibstyles."
  nocomments "$1" | grep '\\bibliographystyle' \
    | inbraces | xargs
}
get_packages() {  # show package names
  [ $# -eq 1 ] || raise "Incorrect usage of get_packages."
  nocomments "$1" | grep -E '\\RequirePackage|\\usepackage' \
    | $sedcmd 's/\[[^][]*\]//g' | $sedcmd '/\[\|\]/d' \
    | $sedcmd 's/AtEndOfClass{//g' | $sedcmd '/newcommand\|#/d' \
    | inbraces | xargs
}
get_themes () {  # fintd \beamerthemeTHEME and \beamercolorthemeTHEME files
  [ $# -eq 2 ] || raise "Incorrect usage of get_themes."
  nocomments "$1" | grep '\\use'"$2" | inbraces \
    | $sedcmd 's/^/beamer'"$2"'/' | xargs
}

#------------------------------------------------------------------------------#
# Get compile options from LaTeX commands
#------------------------------------------------------------------------------#
# Helper functions
errfilt() {  # show only error messages separated by blank lines
  $sedcmd -E '/^! |^l\./!d' | $sedcmd $'s/^! /\\\n/g'
}
errcat() {  # ignore messages about packages and remove empty lines
  errfilt | grep -A2 '^$' | $sedcmd '/^$/d'
}

# Run latex comand, first arg is 1 or 0, indicates whether to always print message
run() {
  local res cmd
  res=$("${@:2}" 2>&1)
  # shellcheck disable=2181
  if [ $? -ne 0 ] || [ "$1" -eq 1 ]; then
    if $raw || [[ "${*:2}" =~ "bibtex" ]]; then
      cmd=cat
    else
      cmd=errcat
    fi
    echo "$res" | $cmd | $sedcmd 's/^/  /'
  fi
}

# First if GIF/animation in file, need to change from Skim to compatible viewer
nocomments "$filename" | grep '\\animategraphics' &>/dev/null \
  && viewer='Adobe Acrobat Reader DC' || viewer='Skim'

# Get actual .bib file or resource; needed for pandoc
# The -n flag prevents printing every single line after running command
read -r -a bibnames < <(get_bibnames "$filename")
bibliography=false
if [ "${#bibnames[@]}" -gt 0 ]; then
  bibliography=true
  bibnames=("${bibnames[@]%.bib}")  # remove extension, if present
  bibfiles=("${bibnames[@]/%/.bib}")  # add back extension
  echo "Bibliographies: ${bibfiles[*]}"
fi

# Detect if we want to run latexdiff on this file
[[ "$filename" =~ .*[0-9][0-9][0-9][0-9]-[0-9][0-9]*.tex ]] \
  && dfilename=${filename%.tex}_changes.tex

# Automatically choose from xelatex and pdflatex; just need xelatex for
# tex files that load fontspec, or use modules that themselves load fontspec
nocomments "$filename" | grep -E 'fontspec|xltxtra' &>/dev/null \
  && latex=xelatex

# Use Lua if beamer present, will be faster
# Also required for beamerposter, not sure about other cases
nocomments "$filename" | grep 'documentclass.*{beamer}' &>/dev/null \
  && latex=lualatex

#------------------------------------------------------------------------------#
# Move required packages and sty files from custom folder
#------------------------------------------------------------------------------#
# Find LaTeX files with kpsewhich, and if not present, copy from custom folder
# Important to call kpsewhich with a list of files rather than calling it
# successively; otherwise can be extremely slow, for some strange reason
# echo "$descrip (${#names[@]}): ${names[@]}"
texfind() {
  local ext descrip texlive copied names files
  ext=$1
  descrip=$2
  [ $# -le 2 ] && return 1
  names=("${@:3}")
  read -r -a files < <(kpsewhich "${names[@]/%/.${ext}}" | xargs)
  for name in "${names[@]}"; do
    file="${name}.${ext}"  # file we want
    # TeX distribution sees file, and it's not in current directory
    if [[ "${files[*]}" =~ "$file" ]] && ! [[ " ${files[*]}" =~ " ./${file}" ]]; then
      texlive+=("$file")
    # Get file from custom templates folder, copy over
    elif [ -r "${templates}/${file}" ]; then
      copied+=("$file")
      cp "${templates}/${file}" ./
    else
      raise "${file} not found"
    fi
  done
  [ ${#texlive[@]} -gt 0 ] && echo "$descrip found in TeXLive: ${texlive[*]}"
  [ ${#copied[@]} -gt 0 ] && echo "$descrip copied from ~/${templates##*/}: ${copied[*]}"
}

# First the custom .cls files
read -r -a classes < <(nocomments "$filename" | grep '\\documentclass' | inbraces)
[ ${#classes[@]} -eq 1 ] || raise "Ambiguous document class: '${classes[*]}'."
class=${classes[0]}
texfind cls "Class file" "$class"

# As above but for the RequirePackage lines in the .cls file. Note this is
# *incomplete*, as it cannot handle multi-line requirepackage commands.
# * Must delete stuff inside [] to account for possible nested {} argument
#   found there; see the regex from here: https://unix.stackexchange.com/a/14840/112647
# * Then we ignore lines with stray brackets; see https://stackoverflow.com/a/17050349/4970632
#   for how to do this with awk; for some reason sed wouldn't work, but gsed did work
# * Finally need to account for newcommand with RequirePackage inside it, which we
#   do by deleting lines containing a '#' character
classfile=$(kpsewhich "$class.cls")
[ -n "$classfile" ] || raise "You should never see this error, already checked for $class.cls existence, check code."
read -r -a required < <(get_packages "$classfile")
texfind sty 'Class sty dependenc(ies)' "${required[@]}"

# As above but for .sty files
# Will also detect \usepackage{package1,package2} lists
read -r -a packages < <(get_packages "$filename")
texfind sty 'Preamble sty file(s)' "${packages[@]}"

# As above but for .bst file
read -r -a bibstyle < <(get_bibstyles "$filename")
texfind bst 'Bibstyle file(s)' "${bibstyle[@]}"

# Next beamer theme
read -r -a themes < <(get_themes "$filename" 'theme')
texfind sty 'Theme file(s)' "${themes[@]}"

# And beamer color theme
read -r -a colorthemes < <(get_themes "$filename" 'colortheme')
texfind sty 'Color theme file(s)' "${colorthemes[@]}"

#------------------------------------------------------------------------------#
# Compile the document(s) and display them
# If bibliography present, compile once to get .aux file, run bibtex
# on the auxfile, then run *twice* for glossary/equation references.
#------------------------------------------------------------------------------#
# Set the flags for compiling
# * Nonstop mode means no interaction, but keep trying to compile if encounter errors.
# * The shellescape option helps use eps figures that aren't in actual .tex directory.
#   See: https://www.scivision.co/pdflatex-error-epstopdf-output-filename-not-allowed-in-restricted-mode/
flags=('-interaction=nonstopmode' '--shell-escape')
files_old=(*)  # glob expansion to every filename
case $latex in
  xelatex)  stylized=XeLaTeX ;;
  pdflatex) stylized=PDFLaTeX ;;
  lualatex) stylized=LuaLaTeX ;;
  *) raise "Unknown compiler \"$latex\"." ;;
esac
echo 'Running with '"${stylized}..."
# Aux file
# WARNING: To keep exit code from pdflatex, pipe later on
# run 0 $latex $flags "$filestem"
echo 'Generating aux file...'  # maybe just need to generate glossary!
run 0 "$latex" -draftmode "${flags[@]}" "$filestem"
if "$bibliography"; then
  echo 'Generating bibliography...'
  run 0 "$bibtex" "$filestem"
  echo 'Incorporating bbl file...'
  run 0 "$latex" -draftmode "${flags[@]}" "$filestem"
fi
echo 'Generating PDF...'
run 1 "$latex" "${flags[@]}" "$filestem"
[ -r "$filestem.pdf" ] || raise "PDF not produced."

# Difference-LaTeX file, with track changes
if $texdiff; then
  if [ -z "$dfilename" ]; then
    echo "Warning: Previous version not found"
    texdiff=false
  else
    # Get files that come *before* current one in alphanumeric sorting
    prefix="${filename%[0-9][0-9][0-9][0-9]-[0-9][0-9]*.tex}"  # parameter expensions are fire yo
    pfiles=("$prefix"[0-9][0-9][0-9][0-9]-[0-9][0-9]*.tex)  # sorted manuscript files (glob is sorted by default)
    for index in "${!pfiles[@]}"; do
      [ "${pfiles[index]}" == "$filename" ] && break
    done
    if [ "$index" -ne 0 ]; then
      # Get difference PDF, with changes highlighted
      pfilename="${pfiles[$((index-1))]}"
      echo "Running latexdiff on ${filename##*/} minus ${pfilename##*/}"
      [ -e "$dfilename" ] && rm "$dfilename"
      latexdiff "$pfilename" "$filename" > "$dfilename"
      # Finish the the pdflatex calls necessary to generate tables of contents, bibligrapyy, etc.
      if ! [ -r $dfilename ]; then
        echo "Warning: Difference file not produced" && texdiff=false
      else
        dfilestem="${dfilename%.tex}"
        if $bibliography; then
          $latex -draftmode "${flags[@]}" "$dfilestem" &>/dev/null
          $bibtex "$dfilestem"  #&>/dev/null
        fi
        # $latex "${flags[@]}" "$dfilestem" | errfilt | tail +2
        $latex -draftmode "${flags[@]}" "$dfilestem" &>/dev/null
        $latex "${flags[@]}" "$dfilestem" | errcat
        if ! [ -r "$dfilestem.pdf" ]; then
          echo "Warning: Difference PDF not produced."
          texdiff=false
        fi
      fi
    fi
  fi
fi

# Convert to docx with pandoc; keeps figures and formats sections with Word styling
if $tex2docx; then
  if ! type pandoc &>/dev/null; then
    echo "Warning: Pandoc not found; use brew install pandoc"
  else
    echo "Running pandoc to convert tex --> docx"
    # echo pandoc --output="$filestem.docx" "${bibflags[@]}" "$filename"
    $bibliography && bibflags=("${bibfiles[@]/#/--bibliography=}")
    pandoc --output="$filestem.docx" "${bibflags[@]}" "$filename"
  fi
fi

# Open the files
open() { echo "Opening \"$2\""; command open -a "$1" "$2"; }
if $texdiff; then
  open "$viewer" "$dfilestem.pdf"
elif $tex2docx; then
  open "Pages" "$filestem.docx"
else
  open "$viewer" "$filestem.pdf"
fi
command open -a "$terminal" &  # bring terminal back into focus

